#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <zconf.h>

int main(int argc, char *argv[])
{
    struct db{
        int id;
        char name[30];
        char lastname[30];
        char lastlastname[30];
        int birth;
    };
    struct db database;
    struct db *ptr, *tmpptr;
    /*if((fin = fopen("text.txt", "r")) == NULL) {
        printf("Файл НЕ открыт");
        getchar();
        return 0;
    }*/
    int fd;
    size_t length;
    int i ;
/*  Ниже следует описание типа структуры, которым мы забьем файл, и двух указателей на
подобный тип. Указатель ptr будет использоваться в качестве начального адреса выделенной
 области памяти, а указатель tmpptr - для перемещения внутри этой области.
    Открываем файл или сначала создаем его (если такого файла не было). Права доступа к файлу
при создании определяем как read and write для всех категорий пользователей (0666). Из-за
ошибки в Linux мы будем вынуждены ниже в системном вызове mmap() разрешить в
отображении файла и чтение, и запись, хотя реально нам нужна только запись. Поэтому и при
открытии файла мы вынуждены задавать O_RDWR. */
    // 0666 (the devil in the beats. Tutututututtututtututu... Drop the beat!)
    fd = open("db.txt", O_RDWR | O_CREAT, 0777);
    if( fd == -1) {
/* Если файл открыть не удалось, выдаем сообщение об ошибке и завершаем работу */
        printf("File open failed!\n");
        return 1;
    }
/* Вычисляем будущую длину файла (мы собираемся записать в него 100000 структур) */
    length = 10*sizeof(struct db);
/* Вновь созданный файл имеет длину 0 Если мы его отобразим в память с такой длиной, то
любая попытка записи в выделенную память приведет к ошибке. Увеличиваем длину файла с
помощью вызова ftruncate(). */
    ftruncate(fd,length);
/* Отображаем файл в память. Разрешенные операции над отображением указываем как
PROT_WRITE | PROT_READ по уже названным причинам. Значение флагов ставим в
MAP_SHARED, так как мы хотим сохранить информацию, которую занесем в отображение,
на диске. Файл отображаем с его начала (offset = 0) и до конца (length = длине файла). */
    ptr = (struct db*)mmap(NULL, length, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);
    close(fd);
    if ( ptr == MAP_FAILED ){
        printf("Mapping failed!\n");
        _exit(2);
    }
/* В цикле заполняем образ файла числами от 1 до 100000 и их квадратами. Для перемещения по
области памяти используем указатель tmpptr, так как указатель ptr на начало образа файла нам
понадобится для прекращения отображения вызовом munmap(). */
    tmpptr = ptr;
    for(i = 1; i <=10; i++){
        tmpptr -> id = i;
        tmpptr++;
    }
/* Прекращаем отображать файл в память, записываем содержимое отображения на диск и
освобождаем память. */
    munmap((struct db*)ptr, length);
    return 0;
}